https://qiita.com/kaki_k/items/6e17597804437ef170ae
DjangoでCRUDアプリを作る

/////////////////////////////


https://awesome-linus.com/2019/04/03/django-get-models-from-another-app/
Djangoで別アプリのモデルからimportしたい

 

結論から言うと、Djangoプロジェクトを起点としてimportするので、以下のようにいつも通りimportしてやれば問題ないのですね。

importの形式
# 個別にimportする場合
from アプリ名.models import クラス名
# まとめてimportする場合
from アプリ名.models import *
 

models.pyで別アプリのモデルをimportしてリレーションを張る時
Djangoでリレーションを張る時
 

カラム名 = models.ForeignKey(モデルのクラス, on_delete=models.CASCADE, verbose_name='説明')
 

実際の設定例
先頭で、別アプリのモデルのクラスであるUserをimportしています。

投稿をしたユーザを判別するためにuser_idカラムを追加し、そこで先程importしたUserモデルを渡しています。

models.py

# 別アプリのUserモデルをimport
from authenticate.models import User

# ブログの投稿のモデルの例
class Post(models.Model):
    """投稿"""
    .
    .
    # user_idカラムを追加
    user_id = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='投稿ユーザ')

 
/////////////////////////////////////////////////





https://qiita.com/aoki_monpro/items/015ca0e94f999122fcf3
【Django】複数アプリで共通のテーブルを使いたいケース

ViewとModelを同じ階層でつくればOK
Pythonの仕様で、import元は同階層か下の階層にある必要があるようです。
(裏技もあるようですが非推奨と思われます。)

ModelはViewから呼ばれるので、
ModelとViewが同階層か、Modelが下階層にあればOKです。

(venv) django_project$ tree
.
├── config     #プロジェクト作成時の設定フォルダ
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-36.pyc
│   │   └── settings.cpython-36.pyc
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── manage.py
└── newapp   #アプリフォルダ(共通)
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── urls.py   #新規作成
    ├── migrations
    │   └── __init__.py
    ├── models           #モデルフォルダ作って  
    │   └── __init__.py
    │   └──reserve.py    #それぞれモデルファイル作成
    │   └──manage.py     #こっちもモデルファイル
    ├── tests.py
    └── views_reserve.py # views.pyファイルの名前を変更
    └── views_manage.py # 新しくファイルを作成
newapp/urls.py 内のルーティングで2つのviewsファイルを指定。

urls.py
from django.urls import path
from . import views_reserve, views_manage  #ファイル名指定
 urlpatterns = [ 
     path('reserve', views_reserve.xxx, name='reserve'), 
     path('manage', views_manage.xxx, name='manage'), 

　xxxには関数名が入ります。

modelsフォルダ内のinit.py に下記の記載をします。

init.py
from newapp.models.reserve import *
from newapp.models.manage import *
これでいくつでもファイル分けられます。
(View側もフォルダつくってわけられますが階層が下がっちゃうので今回のケースではNG)

＝＝＝

コメント頂きまして、INSTALLED_APPS に追記でもいけるようです。

INSTALLED_APPSを

INSTALLED_APPS = [
    ... < 略 > ...    
    'reserve.apps.ReserveConfig',
    'manage.apps.ManageConfig',
    ... < 略 > ...        
]
としてあげれば、

from reserve.models import *
from manage.models import *
でお互い相互にモデルのクラスを持ってくることはできるはずです。
リレーションも、

hogehoge = models.ForeignKey('reserve.FOO', on_delete=models.CASCADE)
とかでいけます。（ベストプラクティスかどうかはさておき）


/////////////////////////////

http://d-policy.com/?p=759
【Django】わかりやすいプロジェクト構成にする
投稿日：2018年9月30日 更新日：2018年12月12日

Djangoプロジェクト構成の問題点
公式のDjangoチュートリアルで紹介されているプロジェクト構成には以下の問題点があると思っています。Djangoでの開発に慣れた方であれば気にならない問題なのですが、フレームワークはRailsしか触ったことのなかった私にとってはそうではありませんでした・・・。

ベースディレクトリの名前と設定ディレクトリの名前が同じでややこしい
htmlやjsといったテンプレート及び静的ファイルがアプリケーション毎にバラバラに配置されてします
ベストプラクティス
ハンズオン形式で順番にDjangoプロジェクトを立ち上げていきましょう。

仮想環境を作成する
$ mkdir mysite           # 仮想環境を構築するディレクトリを作成
$ cd mysite/             # 作成したディレクトリに移動
$ python3 -m venv ENV    # 今回はENVという名前の仮想環境を作成
$ cd ENV                 # ENVディレクトリに移動
$ ls                     # 仮想環境が構築構築されていることを確認
bin		include		lib		pyvenv.cfg
$ source ./bin/activate  # 仮想環境に入る


$ mkdir mysite           # 仮想環境を構築するディレクトリを作成
$ cd mysite/             # 作成したディレクトリに移動
$ python3 -m venv ENV    # 今回はENVという名前の仮想環境を作成
$ cd ENV                 # ENVディレクトリに移動
$ ls                     # 仮想環境が構築構築されていることを確認
bin		include		lib		pyvenv.cfg
$ source ./bin/activate  # 仮想環境に入る
今回はvenvによって仮想環境を使用します。まずはENVという名前の仮想環境を作っていきましょう。基本的に上記のとおりにコマンドを叩いていけばOKです。

仮想環境の概念と利用方法については別記事で紹介しているため、ここでの説明は省きます。

Djangoをインストールする
仮想環境を作成し、その仮想環境に入れたらDjangoをインストールしていきましょう。ご多分に漏れずpipコマンドを使ってインストールしていきます。

$ pip install django         # バージョンを指定しない場合は最新verのDjangoがインストールされる
$ pip install --upgrade pip  # pipのバージョンが最新ではないと言われたらupdateしてもOK
1
2
$ pip install django         # バージョンを指定しない場合は最新verのDjangoがインストールされる
$ pip install --upgrade pip  # pipのバージョンが最新ではないと言われたらupdateしてもOK
ベースディレクトリ名と設定ディレクトリ名を別にする
$ ls                                  # Djangoのインストールによって必要なディレクトリが作成されていることの確認
bin			lib			pyvenv.cfg
include			pip-selfcheck.json
$ mkdir mysite                        # 今回は「mysite」をベースディレクトリ名にする
$ cd mysite/                          # 作成したベースディレクトリに移動
$ ls                                  # この時点ではmysiteディレクトリは空っぽ
$ django-admin startproject config .  # 第一引数に任意の設定ディレクトリ名、第二引数に「.」を指定する
$ ls                                  # 実行後にlsコマンドを叩くと設定ディレクトリとmanage.pyが作成されている
config		manage.py

$ tree                                # ここまででディレクトリ構成は下のようになる
.
├── config  # これが設定ディレクトリ
│&nbsp;&nbsp; ├── __init__.py
│&nbsp;&nbsp; ├── settings.py
│&nbsp;&nbsp; ├── urls.py
│&nbsp;&nbsp; └── wsgi.py
└── manage.py

1 directory, 5 files


$ ls                                  # Djangoのインストールによって必要なディレクトリが作成されていることの確認
bin			lib			pyvenv.cfg
include			pip-selfcheck.json
$ mkdir mysite                        # 今回は「mysite」をベースディレクトリ名にする
$ cd mysite/                          # 作成したベースディレクトリに移動
$ ls                                  # この時点ではmysiteディレクトリは空っぽ
$ django-admin startproject config .  # 第一引数に任意の設定ディレクトリ名、第二引数に「.」を指定する
$ ls                                  # 実行後にlsコマンドを叩くと設定ディレクトリとmanage.pyが作成されている
config		manage.py
 
$ tree                                # ここまででディレクトリ構成は下のようになる
.
├── config  # これが設定ディレクトリ
│&nbsp;&nbsp; ├── __init__.py
│&nbsp;&nbsp; ├── settings.py
│&nbsp;&nbsp; ├── urls.py
│&nbsp;&nbsp; └── wsgi.py
└── manage.py
 
1 directory, 5 files
settings.pyやurls.pyがconfig直下に作成さます。「config」というディレクトリ名はひと目で「あ、これは設定ディレクトリだな」と誰でも推測がつきますね。ちなみに設定ディレクトリの名前は何にしても問題ありません。defaultやrootなど、なんでも大丈夫です。

記事の冒頭で上げた問題点の一つがこれで解消されました。

settings.pyを修正する
次に、テンプレートファイルと静的ファイルを保持する場所をまとめていきます。前項で作成したconfigと同じ階層、つまりベースディレクトリ直下にまとめて配置することによって将来的なメンテナビリティを確保していきましょう。

以下、setting.pyの該当箇所を修正していきます。

・ ・ ・
import os

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
# Djangoプロジェクトを配置したベースディレクトリをBASE_DIRに設定しておく
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
# プロジェクト名(今回ならばmysite)をあわせて定義しておくと非常に便利
PROJECT_NAME = os.path.basename(BASE_DIR)

・ ・ ・

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        # DIRSを設定しておくと、ベースディレクトリ直下の「templates」を最初の検索候補と指定することができる
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

・ ・ ・

# 下記のように設定することで静的ファイルを一箇所にまとめて管理・参照することができる
STATIC_URL = '/static/'
STATICFILES_DIR = [os.path.join(BASE_DIR, 'static')]
STATIC_ROOT = os.path.join(BASE_DIR, 'static_root')

・ ・ ・
import os
 
# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
# Djangoプロジェクトを配置したベースディレクトリをBASE_DIRに設定しておく
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
# プロジェクト名(今回ならばmysite)をあわせて定義しておくと非常に便利
PROJECT_NAME = os.path.basename(BASE_DIR)
 
・ ・ ・
 
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        # DIRSを設定しておくと、ベースディレクトリ直下の「templates」を最初の検索候補と指定することができる
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
 
・ ・ ・
 
# 下記のように設定することで静的ファイルを一箇所にまとめて管理・参照することができる
STATIC_URL = '/static/'
STATICFILES_DIR = [os.path.join(BASE_DIR, 'static')]
STATIC_ROOT = os.path.join(BASE_DIR, 'static_root')
 
・ ・ ・
これで準備が整いました。

ベースディレクトリ直下にtemplatesディレクトリとstaticディレクトリを作成しましょう。

出来上がったDjangoプロジェクトの構成
.
├── config  # これが設定ディレクトリ
│    ├── __init__.py
│    ├── __pycache__
│    │    ├── __init__.cpython-36.pyc
│    │    └── settings.cpython-36.pyc
│    ├── settings.py
│    ├── urls.py
│    └── wsgi.py
├── manage.py
├── polls  # アプリケーションディレクトリ
│    ├── __init__.py
│    ├── admin.py
│    ├── apps.py
│    ├── migrations
│    │    └── __init__.py
│    ├── models.py
│    ├── tests.py
│    └── views.py
├── static  # 静的ファイルを保持するディレクトリ(新規作成)
│    ├── images
│    ├── js
│    └── polls  # アプリケーション単位で静的ファイルを保持する(新規作成)
└── templates  # テンプレートファイルを保持するディレクトリ(新規作成)
    ├── base.html
    └── polls  # アプリケーション単位でテンプレートファイルを保持する(新規作成)
        └── index.html

.
├── config  # これが設定ディレクトリ
│    ├── __init__.py
│    ├── __pycache__
│    │    ├── __init__.cpython-36.pyc
│    │    └── settings.cpython-36.pyc
│    ├── settings.py
│    ├── urls.py
│    └── wsgi.py
├── manage.py
├── polls  # アプリケーションディレクトリ
│    ├── __init__.py
│    ├── admin.py
│    ├── apps.py
│    ├── migrations
│    │    └── __init__.py
│    ├── models.py
│    ├── tests.py
│    └── views.py
├── static  # 静的ファイルを保持するディレクトリ(新規作成)
│    ├── images
│    ├── js
│    └── polls  # アプリケーション単位で静的ファイルを保持する(新規作成)
└── templates  # テンプレートファイルを保持するディレクトリ(新規作成)
    ├── base.html
    └── polls  # アプリケーション単位でテンプレートファイルを保持する(新規作成)
        └── index.html
設定、アプリケーション、静的ファイル、テンプレートファイルと、用途や機能に合わせてディレクトリ構成を最適化することができました。

仮にこのDjangoプロジェクトが自分の手を離れたとしても、READMEに上記のディレクトリ構成にした旨とその意図を記録しておけば、将来的に難解な構成にならないのではないでしょうか。